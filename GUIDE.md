# RISC-V Assembler Technical Guide

This document provides a detailed technical overview of the assembler project.

## Architecture Overview

The assembler is designed to translate RISC-V assembly source code into an
executable ELF (Executable and Linkable Format) binary. It works on a while
program (any number of `*.s` files) at once and is designed for small
educational projects, so some assembler+linker structures are simplified.

The main phases are:

1.  **Tokenizing**: Converts a raw line of source code into a stream of tokens.
2.  **Parsing**: Parse the token stream for a line into an AST. All source files
    are parsed and collected into a single Vec of `SourceFile` objects, each
    with a Vec of `Line` objects that contain the AST for the line.
    Indexes into these two levels of Vecs are used throughout to refer to
    specific instructions, labels, etc. All `SourceFile`s are gathered into a
    single `Source` object, which contains the `SourceFile`s and also the
    expected sizes of the three segments.
3.  **Size guess**: A simple pass over all `SourceFile`/`Line`s assigns an
    initial guess about where code/data generated by each line will be relative
    to the beginning of its segment (text, data, bss). This is a simple guess:
    it advances by four bytes for instructions and pseudoinstructions, zero for
    labels and non-data directives, and a computed length for data-generating
    directives.  The total guessed sizes of text, data, and bss are also
    accumulated as this goes. While this is logically a separate pass from the
    parsing phase, in practice it is implemented as parsing happens.
4.  **Symbol resolution**: A single pass with back-patching resolves all symbol
    references and collects the lists of global and local symbols (but not their
    values) that will be exported to the ELF binary. References are recorded as
    indexes into the `SourceFile` Vec and `Line` Vec, i.e., internal
    pointers to the `Line` that defines a label/symbol that is referenced.
5.  **Code generation and expression calculation**: A single pass generates the
    text, data, and bss segments as raw `Vec<u8>` blocks for text and data and a
    simple `u64` counter for bss. The in-memory start address of each segment is
    computed (text at a fixed starting address, data at the first 4k page
    boundary after the end of test, bss right after data) and then each line is
    encoded. Expressions are calculated on demand, with symbol references
    followed and calculated lazily with memoizing and cycle detection. If an
    line encodes to a different address than guessed, the guess is updated.
    Local and global symbol values are also recorded for the ELF symbol table.
6.  **Relaxation**: If any addresses changed during a code generation pass, the
    entire pass is repeated from scratch. The only data brought forward is the
    updated address guesses.
7.  **ELF generation**: The symbol table and segment contents from the final
    code generation pass are used to build and write the ELF executable file.

## Core Types

### AST (`src/ast.rs`)

The types for tokenizing and parsing. This file has detailed comments about the
rules of the concrete syntax including the parser grammar.

Tokenizer types:

*   `Register`: an enum with the 32 architectural registers for RISC-V (X0–X31),
    generated by the tokenizer (which reads x- name directly and also maps ABI
    names like `zero`, `ra`, `sp`, etc., including both `fp` and `s0`, to the
    matching `Register` variant) and embedded in instruction ASTs as well.
*   `DirectiveOp`: an enum of the supported assembler directive tokens:
    *   `Global`: ".global or .globl"
    *   `Equ`: ".equ" or ".set"
    *   `Text`, `Data`, `Bss`: ".text", ".data", and ".bss", respectively
    *   `Space`: ".space"
    *   `String`, `Asciz`: ".string" and ".asciz", respectively
    *   `Byte`, `TwoByte`, `FourByte`, `EightByte`: ".byte", ".2byte", ".4byte",
        and ".8byte", respectively
    *   `Balign`: ".balign"
*   `OperatorOp`: an enum of the supported expression operators:
    *   `Plus`, `Minus`, `Multiply`, `Divide`, `Modulo`, `LeftShift`,
        `RightShift`, `BitwiseOr`, `BitwiseAnd`, `BitwiseXor`, `BitwiseNot`
*   `Token`: a single token. an enum with:
    *   `Identifier(String)`: a symbol, label, or instruction mnemonic
    *   `Register(Register)`: all register names are reserved words
    *   `Integer(i64)`: an integer literal
    *   `StringLiteral(String)`: a string
    *   `Directive(DirectiveOp)`: assembler directives are reserved words
    *   `Colon`, `Comma`, `OpenParen`, `CloseParen`: core instruction syntax
        punctuation
    *   `Operator(OperatorOp)`: expression operators are all explicitly
        recognized by the tokenizer
    *   `Dot`: '.' in an expression represents the current address

AST types (some tokenizer types are carried over):

*   `Line`: `Location` plus `LineContent`
*   `Location`: a file name and line number, attached to every parsed source
    line and passed as part of error types. Errors normally bubble to the top
    and then the `Location` is used to re-read the source file, find the
    referenced line, and gather 3 lines of context above and below. The error
    message is then augmented with those 7 lines of source with line numbers,
    and the line where the error originated marked clearly.
*   `LineContent`: either a `Label(String)`, an `Instruction(Instruction)`, or
    a `Directive(Directive)`. Note that source lines with a label AND an
    instruction/directive are split into two `Line` entries, the label followed
    by the instruction/directive, with the same `Location`
*   `Instruction`: an instruction. Note that most aliases, abbreviations, and
    other sugar are desugared at parse time into the core forms. These
    categories are selected by considering common encoding format, common
    `Display` trait formatting, or groups of special cases that make sense
    together:
    *   `RType`: e.g., "add a0, t1, s2"
    *   `IType`: e.g., "xori a0, t1, 5"
    *   `BType`: e.g., "bge a0, t1, target"
    *   `UType`: e.g., "lui a0, 0x1234"
    *   `JType`: e.g., "jal rd, puts"
    *   `Special`: special case instructions with no operands, e.g., "ecall"
    *   `LoadStore`: e.g., "ld a0, 16(sp)" or "sw s2, 20+12(s0)"
    *   `Pseudo`: pseudo-instructions that are not desugared at parse time:
        "li", "la", load global: "ld a0, counter", store global: "sd a0, counter, t0",
        "call", and "tail"
*   all the other types for specific instruction groups, expressions,
    directives, etc.


## Expression evaluation

We have some more specific constraints on expression evaluation. We tag every
value as Address or Integer and have these rules:

* Address + Address = error
* Address - Address = Integer
* Address + Integer = Address
* Integer + Address = Address
* Multiply, Divide, Modulo, shifts, negate, and bitwise ops only defined for
  Integers, error on Address
* . is an Address
* labels are Addresses
* integer literals are Integers
* .equ symbol type is based on the expression computed
